<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFL Playoff Bracket 2025-2026</title>

    <!-- Social Media Meta Tags (Open Graph) -->
    <meta property="og:title" content="NFL Playoff 2025-2026 Bracket Predictor">
    <meta property="og:description" content="Predict the 2025-2026 NFL Playoff winners and download your custom bracket!">
    <meta property="og:image" content="https://static.www.nfl.com/image/upload/t_editorial_landscape_8_desktop_mobile/f_auto/league/vgkau6d9kyttima2ljnx.jpg">
    <meta property="og:type" content="website">
    
    <!-- Twitter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="NFL Playoff 2025-2026 Bracket Predictor">
    <meta name="twitter:description" content="Predict the 2025-2026 NFL Playoff winners and download your custom bracket!">
    <meta name="twitter:image" content="https://static.www.nfl.com/image/upload/t_editorial_landscape_8_desktop_mobile/f_auto/league/vgkau6d9kyttima2ljnx.jpg">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            margin: 0 auto;
        }

        .countdown-container {
            background: #013369;
            color: white;
            text-align: center;
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 8px;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .countdown-timer {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 5px;
            font-family: 'Courier New', Courier, monospace;
        }

        .countdown-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .countdown-value {
            font-size: 1.5em;
        }

        .countdown-label {
            font-size: 0.7em;
            text-transform: uppercase;
            opacity: 0.8;
        }

        /* Stats Mode Styles */
        .stats-mode .team {
            cursor: default;
        }

        .stats-mode .team:hover {
            transform: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .stats-badge {
            position: absolute;
            top: 2px;
            left: 2px;
            background: #013369;
            color: white;
            font-size: 0.75em;
            font-weight: bold;
            padding: 3px 6px;
            border-radius: 8px;
            min-width: 28px;
            text-align: center;
            z-index: 10;
        }

        .stats-badge.higher {
            background: #28a745;
        }

        .stats-badge.lower {
            background: #dc3545;
        }

        .team.winner .stats-badge {
            background: #28a745;
        }

        .team.eliminated {
            opacity: 0.5;
        }

        .team.eliminated .stats-badge {
            background: #dc3545;
        }

        .team.result-winner {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border: 2px solid #28a745;
        }

        .team.result-loser {
            opacity: 0.6;
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            border: 2px solid #dc3545;
        }

        .team.result-loser .team-name {
            text-decoration: line-through;
            color: #dc3545;
        }

        .team.prediction-correct {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border: 2px solid #28a745;
        }

        .team.prediction-wrong {
            opacity: 0.6;
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            border: 2px solid #dc3545;
        }

        .team.prediction-wrong .team-name {
            text-decoration: line-through;
            color: #dc3545;
        }

        .champion-team.prediction-correct {
            border: 3px solid #28a745;
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
        }

        .champion-team.prediction-wrong {
            opacity: 0.6;
            border: 3px solid #dc3545;
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
        }

        .champion-team.prediction-wrong .team-name {
            text-decoration: line-through;
            color: #dc3545;
        }

        .team-score {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.1em;
            font-weight: bold;
            color: #333;
            min-width: 24px;
            text-align: center;
        }

        .team.winner .team-score {
            color: #28a745;
        }

        .team.eliminated .team-score {
            color: #999;
        }

        .team.predicted {
            opacity: 0.7;
        }

        .team.predicted .team-name {
            color: #888;
        }

        .team.predicted .seed {
            color: #999;
        }

        .champion-team.predicted {
            background: #e9ecef;
            opacity: 0.8;
        }

        .champion-team.predicted .team-name {
            color: #888;
        }

        .stats-header {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .stats-header h2 {
            color: #013369;
            margin-bottom: 10px;
        }

        .stats-summary {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        .stats-item {
            text-align: center;
        }

        .stats-item .value {
            font-size: 2em;
            font-weight: bold;
            color: #013369;
        }

        .stats-item .label {
            font-size: 0.9em;
            color: #666;
        }

        .alive-box {
            display: inline-block;
            background: #013369;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
            margin: 10px 0;
        }

        .alive-box #alive-count {
            font-size: 1.4em;
        }

        .bracket-nav {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
        }

        .nav-btn {
            background: #013369;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
        }

        .nav-btn:hover {
            background: #024a9e;
        }

        #bracket-position {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            min-width: 100px;
            text-align: center;
        }

        .bracket-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
        }

        .status-alive {
            background: #28a745;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .status-eliminated {
            background: #dc3545;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        #bracket-score {
            font-size: 1.1em;
            font-weight: bold;
            color: #333;
        }

        .back-btn {
            background: #6c757d !important;
        }

        .back-btn:hover {
            background: #5a6268 !important;
        }

        .alive-subtitle {
            color: #666;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .leaderboard-list {
            max-width: 500px;
            margin: 20px auto;
            text-align: left;
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            background: white;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .leaderboard-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .leaderboard-rank {
            font-size: 1.4em;
            font-weight: bold;
            color: #013369;
            min-width: 40px;
        }

        .leaderboard-rank.gold { color: #FFD700; }
        .leaderboard-rank.silver { color: #C0C0C0; }
        .leaderboard-rank.bronze { color: #CD7F32; }

        .leaderboard-creator {
            flex: 1;
            font-weight: 500;
            color: #333;
        }

        .leaderboard-score {
            font-weight: bold;
            color: #013369;
            font-size: 1.1em;
        }

        .bracket-rank {
            font-size: 3em;
            font-weight: bold;
            color: #013369;
            margin-bottom: 5px;
        }

        .bracket-rank.gold { color: #FFD700; }
        .bracket-rank.silver { color: #C0C0C0; }
        .bracket-rank.bronze { color: #CD7F32; }

        .stats-description {
            color: #666;
            font-size: 0.95em;
            margin-top: 10px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        header {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }

        header h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
            color: #013369;
        }

        header p {
            font-size: 1.1em;
            color: #666;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
        }

        .btn {
            padding: 12px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
        }

        .btn-secondary {
            background: #f44336;
            color: white;
        }

        .btn-secondary:hover {
            background: #da190b;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
        }

        #bracket {
            background: white;
            padding: 20px 0;
            overflow-x: auto;
        }

        .bracket-grid {
            display: grid;
            grid-template-columns: repeat(3, 200px) 280px repeat(3, 200px);
            gap: 0;
            width: max-content;
            margin: 0 auto;
        }

        .rounds-header {
            display: contents;
        }

        .round-header-item {
            text-align: center;
            font-weight: bold;
            color: #666;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 10px 0 15px;
            border-bottom: 2px solid #eee;
        }

        .round-header-item.superbowl-header {
            padding: 10px 0 15px;
            font-size: 1em;
            color: #D50A0A;
            font-weight: 900;
            letter-spacing: 1.5px;
        }

        .conference-label {
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            position: absolute;
            top: -35px;
            left: 0;
            right: 0;
        }

        .conference-label.afc {
            color: #013369;
        }

        .conference-label.nfc {
            color: #D50A0A;
        }

        #afc-conf-content,
        #nfc-conf-content {
            position: relative;
        }

        .bracket-content {
            display: contents;
        }

        .round-column {
            padding: 20px 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
        }

        .conference-logo {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 0;
            opacity: 0.15; /* Subtle background effect to not interfere with text */
        }

        .conference-logo img {
            height: 90px;
            width: auto;
        }

        /* Ensure content sits above the logo */
        .round-content {
            z-index: 1;
        }

        .round-column.superbowl-column {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .superbowl-logo {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 0;
        }

        .superbowl-logo img {
            height: 140px;
            width: auto;
        }

        .superbowl-teams {
            z-index: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            max-width: 260px;
        }

        .round-content {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            flex: 1;
            min-height: 500px;
        }

        .matchup {
            display: flex;
            flex-direction: column;
            gap: 4px;
            position: relative;
            padding: 8px 0;
            margin-bottom: 12px;
        }

        .matchup:last-child {
            margin-bottom: 0;
        }

        .team {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: #f5f5f5;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            height: 55px;
            width: 100%;
        }

        .team-logo-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            flex-shrink: 0;
        }

        .team:hover {
            background: #e8f4f8;
            border-color: #2196F3;
        }

        .team.selected {
            background: #e3f2fd;
            border-color: #2196F3;
            box-shadow: 0 4px 8px rgba(33, 150, 243, 0.3);
        }

        .team.winner {
            background: #c8e6c9;
            border-color: #4CAF50;
            font-weight: bold;
        }

        .team.empty {
            background: #fafafa;
            border: 2px dashed #ccc;
            cursor: default;
            justify-content: center;
            color: #999;
        }

        .team.empty:hover {
            background: #fafafa;
            transform: none;
            border-color: #ccc;
        }

        .seed {
            font-weight: bold;
            color: #666;
            font-size: 0.65em;
            text-align: center;
        }

        .team-logo {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        .team-name {
            flex: 1;
            font-size: 0.9em;
        }

        .team.bye-team {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border: 2px solid #81c784;
        }

        .team.bye-opponent {
            background: #f0f0f0;
            border: 2px solid #ccc;
            cursor: default;
            color: #999;
        }

        .team.bye-opponent:hover {
            transform: none;
            background: #f0f0f0;
            border-color: #ccc;
        }

        .bye-label {
            font-size: 0.65em;
            color: #4CAF50;
            font-weight: bold;
            margin-left: auto;
            text-transform: uppercase;
            background: #4CAF50;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .superbowl-teams .team:hover {
            transform: none;
        }

        .champion-team {
            width: 100%;
            height: 114px;
            padding: 15px 15px;
            background: linear-gradient(135deg, #FFD700 0%, #FFC107 50%, #FFD700 100%);
            border: 4px solid #DAA520;
            border-radius: 8px;
            font-size: 1.15em;
            font-weight: bold;
            color: #333;
            box-shadow:
                0 8px 20px rgba(255, 215, 0, 0.5),
                inset 0 2px 4px rgba(255, 255, 255, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .champion-team .sb-logo {
            display: none;
        }

        .champion-team .team-logo {
            width: 80px;
            height: 80px;
            flex-shrink: 0;
        }

        .champion-team .team-name {
            font-size: 1.6em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .champion-team .trophy {
            font-size: 1.5em;
        }

        .champion-team.empty {
            background: linear-gradient(135deg, #f8f8f8 0%, #e8e8e8 100%);
            border: 3px dashed #ccc;
            color: #999;
            box-shadow: none;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            z-index: 2000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #013369;
        }

        .loading-overlay.active {
            display: flex;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #013369;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .scroll-indicator {
            display: none;
            text-align: center;
            color: #666;
            font-size: 0.9em;
            margin-bottom: 15px;
            padding: 8px;
            background: #f0f0f0;
            border-radius: 4px;
        }

        @media (max-width: 1500px) {
            .scroll-indicator {
                display: block;
            }
        }

        @media (max-width: 1200px) {
            header h1 {
                font-size: 1.8em;
            }
        }

        .creator-info {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px;
        }

        .creator-info label {
            display: block;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .creator-info input {
            padding: 10px 15px;
            font-size: 1em;
            border: 2px solid #ddd;
            border-radius: 6px;
            width: 300px;
            max-width: 100%;
            box-sizing: border-box;
        }

        .creator-info input:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 5px rgba(33, 150, 243, 0.3);
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            header h1 {
                font-size: 1.5em;
            }

            #bracket {
                padding: 20px 10px;
            }

            .creator-info input {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="loading-overlay" class="loading-overlay">
            <div class="spinner"></div>
            <div>Generating your bracket...</div>
        </div>
        <div id="stats-header" class="stats-header" style="display: none;">
            <h2>Welcome to NFL Romania #1 BATTLE ROYALE</h2>
            <div class="alive-box" id="alive-box" style="cursor: pointer;" onclick="openLeaderboard()">
                View Leaderboard
            </div>
            <div class="alive-subtitle"><span id="alive-count">0</span> brackets still alive</div>
            <p class="stats-description">See how everyone predicted the 2025-2026 NFL Playoffs. Percentages show how many brackets picked each team to advance. <strong>Grey text indicates predicted advancement</strong> based on user votes. <strong>Click the box above to view the leaderboard!</strong></p>
        </div>

        <div id="leaderboard-header" class="stats-header" style="display: none;">
            <h2>üèÜ Leaderboard - Top 10</h2>
            <div id="leaderboard-list" class="leaderboard-list"></div>
            <div class="alive-box back-btn" onclick="closeLeaderboard()" style="cursor: pointer;">
                ‚Üê Back to Stats
            </div>
        </div>

        <div id="bracket-viewer-header" class="stats-header" style="display: none;">
            <div class="bracket-rank" id="bracket-rank">#1</div>
            <h2 id="bracket-creator-name">Bracket by: Anonymous</h2>
            <div class="bracket-nav">
                <button class="nav-btn" id="prev-btn" onclick="prevBracket()">‚Üê Previous</button>
                <span id="bracket-position">1 / 10</span>
                <button class="nav-btn" id="next-btn" onclick="nextBracket()">Next ‚Üí</button>
            </div>
            <div class="bracket-info">
                <span id="bracket-score">Score: 0 pts</span>
            </div>
            <div class="alive-box back-btn" onclick="closeToLeaderboard()" style="cursor: pointer;">
                ‚Üê Back to Leaderboard
            </div>
        </div>

        <div class="countdown-container" id="countdown-container">
            <div>Create your bracket before kickoff:</div>
            <div id="countdown" class="countdown-timer">
                <div class="countdown-item">
                    <span id="days" class="countdown-value">00</span>
                    <span class="countdown-label">Days</span>
                </div>
                <div class="countdown-item">
                    <span id="hours" class="countdown-value">00</span>
                    <span class="countdown-label">Hrs</span>
                </div>
                <div class="countdown-item">
                    <span id="minutes" class="countdown-value">00</span>
                    <span class="countdown-label">Min</span>
                </div>
                <div class="countdown-item">
                    <span id="seconds" class="countdown-value">00</span>
                    <span class="countdown-label">Sec</span>
                </div>
            </div>
        </div>

        <header>
            <p>Click on teams to predict winners and advance them through the bracket. Enter your name and download your bracket as an image to share your predictions!</p>
        </header>

        <div class="creator-info">
            <input type="text" id="creator-name" placeholder="Enter your name here">
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="exportBracket()">Download Bracket</button>
            <button class="btn btn-secondary" onclick="resetBracket()">Reset Bracket</button>
        </div>

        <div class="scroll-indicator">‚Üî Swipe to view full bracket</div>
        <div id="bracket">
            <div class="bracket-grid">
                <!-- Header Row -->
                <div class="rounds-header">
                    <div class="round-header-item">Wild Card</div>
                    <div class="round-header-item">Divisional</div>
                    <div class="round-header-item">Conference</div>
                    <div class="round-header-item superbowl-header">Super Bowl</div>
                    <div class="round-header-item">Conference</div>
                    <div class="round-header-item">Divisional</div>
                    <div class="round-header-item">Wild Card</div>
                </div>

                <!-- Bracket Content Row -->
                <div class="bracket-content">
                    <!-- AFC Wild Card -->
                    <div class="round-column afc">
                        <div id="afc-wc-content" class="round-content"></div>
                    </div>
                    <!-- AFC Divisional -->
                    <div class="round-column afc">
                        <div id="afc-div-content" class="round-content"></div>
                    </div>
                    <!-- AFC Conference -->
                    <div class="round-column afc">
                        <div class="conference-logo">
                            <img src="https://upload.wikimedia.org/wikipedia/commons/7/7a/American_Football_Conference_logo.svg" alt="AFC Logo">
                        </div>
                        <div id="afc-conf-content" class="round-content"></div>
                    </div>
                    <!-- Super Bowl -->
                    <div class="round-column superbowl-column">
                        <div class="superbowl-logo">
                            <img src="https://upload.wikimedia.org/wikipedia/en/b/b0/Super_Bowl_LX_Logo.svg" alt="Super Bowl LX">
                        </div>
                        <div class="superbowl-teams">
                            <div class="team empty" data-round="sb" data-conference="afc" data-slot="0">
                                <span>AFC Champion</span>
                            </div>
                            <div class="champion-team empty">
                                <span>TBD</span>
                            </div>
                            <div class="team empty" data-round="sb" data-conference="nfc" data-slot="1">
                                <span>NFC Champion</span>
                            </div>
                        </div>
                    </div>
                    <!-- NFC Conference -->
                    <div class="round-column nfc">
                        <div class="conference-logo">
                            <img src="https://upload.wikimedia.org/wikipedia/commons/6/6f/National_Football_Conference_logo.svg" alt="NFC Logo">
                        </div>
                        <div id="nfc-conf-content" class="round-content"></div>
                    </div>
                    <!-- NFC Divisional -->
                    <div class="round-column nfc">
                        <div id="nfc-div-content" class="round-content"></div>
                    </div>
                    <!-- NFC Wild Card -->
                    <div class="round-column nfc">
                        <div id="nfc-wc-content" class="round-content"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Team data - easy to update with actual playoff teams
        // 2025-2026 NFL Playoff Teams (Updated after regular season)
        const teams = {
            AFC: [
                { seed: 1, name: "Denver Broncos", abbr: "DEN", logo: "https://a.espncdn.com/i/teamlogos/nfl/500/den.png" },
                { seed: 2, name: "New England Patriots", abbr: "NE", logo: "https://a.espncdn.com/i/teamlogos/nfl/500/ne.png" },
                { seed: 3, name: "Jacksonville Jaguars", abbr: "JAX", logo: "https://a.espncdn.com/i/teamlogos/nfl/500/jax.png" },
                { seed: 4, name: "Pittsburgh Steelers", abbr: "PIT", logo: "https://a.espncdn.com/i/teamlogos/nfl/500/pit.png" },
                { seed: 5, name: "Houston Texans", abbr: "HOU", logo: "https://a.espncdn.com/i/teamlogos/nfl/500/hou.png" },
                { seed: 6, name: "Buffalo Bills", abbr: "BUF", logo: "https://a.espncdn.com/i/teamlogos/nfl/500/buf.png" },
                { seed: 7, name: "Los Angeles Chargers", abbr: "LAC", logo: "https://a.espncdn.com/i/teamlogos/nfl/500/lac.png" }
            ],
            NFC: [
                { seed: 1, name: "Seattle Seahawks", abbr: "SEA", logo: "https://a.espncdn.com/i/teamlogos/nfl/500/sea.png" },
                { seed: 2, name: "Chicago Bears", abbr: "CHI", logo: "https://a.espncdn.com/i/teamlogos/nfl/500/chi.png" },
                { seed: 3, name: "Philadelphia Eagles", abbr: "PHI", logo: "https://a.espncdn.com/i/teamlogos/nfl/500/phi.png" },
                { seed: 4, name: "Carolina Panthers", abbr: "CAR", logo: "https://a.espncdn.com/i/teamlogos/nfl/500/car.png" },
                { seed: 5, name: "Los Angeles Rams", abbr: "LAR", logo: "https://a.espncdn.com/i/teamlogos/nfl/500/lar.png" },
                { seed: 6, name: "San Francisco 49ers", abbr: "SF", logo: "https://a.espncdn.com/i/teamlogos/nfl/500/sf.png" },
                { seed: 7, name: "Green Bay Packers", abbr: "GB", logo: "https://a.espncdn.com/i/teamlogos/nfl/500/gb.png" }
            ]
        };

        // Bracket state
        let bracket = {
            AFC: {
                wildcard: [],
                divisional: [],
                conference: []
            },
            NFC: {
                wildcard: [],
                divisional: [],
                conference: []
            },
            superbowl: [],
            champion: null
        };

        // Initialize bracket
        function initBracket() {
            // Set up Wild Card matchups
            setupWildCard('AFC');
            setupWildCard('NFC');
        }

        function setupWildCard(conference) {
            const confTeams = teams[conference];
            const wcContainer = document.getElementById(`${conference.toLowerCase()}-wc-content`);

            // First matchup: #1 seed with BYE
            const byeMatchup = document.createElement('div');
            byeMatchup.className = 'matchup';

            // #1 seed
            const seed1Div = document.createElement('div');
            seed1Div.className = 'team bye-team';
            seed1Div.dataset.conference = conference;
            seed1Div.dataset.round = 'wildcard-bye';
            seed1Div.dataset.slot = '0';
            seed1Div.dataset.teamData = JSON.stringify(confTeams[0]);
            seed1Div.innerHTML = `
                <div class="team-logo-container">
                    <img class="team-logo" src="${confTeams[0].logo}" alt="${confTeams[0].name}" onerror="this.style.display='none'">
                    <span class="seed">#1</span>
                </div>
                <span class="team-name">${confTeams[0].name}</span>
            `;
            byeMatchup.appendChild(seed1Div);

            // BYE opponent slot
            const byeOpponent = document.createElement('div');
            byeOpponent.className = 'team bye-opponent';
            byeOpponent.innerHTML = '<span>‚Äî BYE ‚Äî</span>';
            byeMatchup.appendChild(byeOpponent);

            wcContainer.appendChild(byeMatchup);

            // Wild Card matchups: #2 vs #7, #3 vs #6, #4 vs #5
            const matchups = [
                [confTeams[1], confTeams[6]], // #2 vs #7
                [confTeams[2], confTeams[5]], // #3 vs #6
                [confTeams[3], confTeams[4]]  // #4 vs #5
            ];

            matchups.forEach((matchup, idx) => {
                const matchupDiv = document.createElement('div');
                matchupDiv.className = 'matchup';

                matchup.forEach((team, teamIdx) => {
                    const teamDiv = createTeamElement(team, conference, 'wildcard', idx * 2 + teamIdx);
                    matchupDiv.appendChild(teamDiv);
                });

                wcContainer.appendChild(matchupDiv);
            });

            // Set up Divisional round slots
            setupDivisional(conference);
        }

        function setupDivisional(conference) {
            const divContainer = document.getElementById(`${conference.toLowerCase()}-div-content`);
            const confTeams = teams[conference];

            // Matchup 1: #1 seed (BYE) vs Lowest Remaining Seed (Dynamic)
            const matchup1 = document.createElement('div');
            matchup1.className = 'matchup';

            // Slot 0: #1 seed with BYE (top position)
            const byeTeam = createByeTeamElement(confTeams[0], conference, 'divisional', 0);
            matchup1.appendChild(byeTeam);

            // Slot 1: TBD (Lowest remaining seed from Wild Card)
            matchup1.appendChild(createEmptySlot(conference, 'divisional', 1));

            divContainer.appendChild(matchup1);

            // Matchup 2: Best Remaining vs Middle Remaining (Dynamic)
            const matchup2 = document.createElement('div');
            matchup2.className = 'matchup';

            matchup2.appendChild(createEmptySlot(conference, 'divisional', 2));
            matchup2.appendChild(createEmptySlot(conference, 'divisional', 3));

            divContainer.appendChild(matchup2);

            // Set up Conference championship slots
            setupConference(conference);
        }

        function createByeTeamElement(team, conference, round, slot) {
            const div = document.createElement('div');
            div.className = 'team';
            div.dataset.conference = conference;
            div.dataset.round = round;
            div.dataset.slot = slot;
            div.dataset.teamData = JSON.stringify(team);

            div.innerHTML = `
                <div class="team-logo-container">
                    <img class="team-logo" src="${team.logo}" alt="${team.name}" onerror="this.style.display='none'">
                    <span class="seed">#${team.seed}</span>
                </div>
                <span class="team-name">${team.name}</span>
            `;

            div.onclick = () => selectTeam(div);

            return div;
        }

        function setupConference(conference) {
            const confContainer = document.getElementById(`${conference.toLowerCase()}-conf-content`);

            const matchupDiv = document.createElement('div');
            matchupDiv.className = 'matchup';

            for (let i = 0; i < 2; i++) {
                const teamDiv = createEmptySlot(conference, 'conference', i);
                matchupDiv.appendChild(teamDiv);
            }

            confContainer.appendChild(matchupDiv);
        }

        function createTeamElement(team, conference, round, slot) {
            const div = document.createElement('div');
            div.className = 'team';
            div.dataset.conference = conference;
            div.dataset.round = round;
            div.dataset.slot = slot;
            div.dataset.teamData = JSON.stringify(team);

            div.innerHTML = `
                <div class="team-logo-container">
                    <img class="team-logo" src="${team.logo}" alt="${team.name}" onerror="this.style.display='none'">
                    <span class="seed">#${team.seed}</span>
                </div>
                <span class="team-name">${team.name}</span>
            `;

            div.onclick = () => selectTeam(div);

            return div;
        }

        function createEmptySlot(conference, round, slot) {
            const div = document.createElement('div');
            div.className = 'team empty';
            div.dataset.conference = conference;
            div.dataset.round = round;
            div.dataset.slot = slot;
            div.innerHTML = '<span>TBD</span>';
            return div;
        }

        function selectTeam(teamDiv) {
            if (teamDiv.classList.contains('empty')) return;

            const conference = teamDiv.dataset.conference;
            const round = teamDiv.dataset.round;
            const slot = parseInt(teamDiv.dataset.slot);
            const teamData = JSON.parse(teamDiv.dataset.teamData);

            // Get matchup (same round, slot divided by 2)
            const matchupIdx = Math.floor(slot / 2);
            const allTeamsInMatchup = document.querySelectorAll(
                `[data-conference="${conference}"][data-round="${round}"][data-slot="${matchupIdx * 2}"], ` +
                `[data-conference="${conference}"][data-round="${round}"][data-slot="${matchupIdx * 2 + 1}"]`
            );

            // Remove selection from other team in matchup
            allTeamsInMatchup.forEach(t => t.classList.remove('selected', 'winner'));

            // Mark this team as winner
            teamDiv.classList.add('selected', 'winner');

            // Advance to next round
            advanceTeam(teamData, conference, round, matchupIdx);
        }

        function advanceTeam(team, conference, round, matchupIdx) {
            let nextRound, nextSlot;

            if (round === 'wildcard') {
                // For NFL, we reseed after Wild Card.
                // We need to wait for all 3 WC winners in this conference.
                recalcDivisionalMatchups(conference);

            } else if (round === 'divisional') {
                nextRound = 'conference';
                nextSlot = matchupIdx; // 0 or 1
                updateSlot(team, conference, nextRound, nextSlot);

            } else if (round === 'conference') {
                // Advance to Super Bowl
                const sbSlot = conference === 'AFC' ? 0 : 1;
                const sbTeam = document.querySelector(`[data-round="sb"][data-slot="${sbSlot}"]`);

                sbTeam.className = 'team';
                sbTeam.dataset.teamData = JSON.stringify(team);
                sbTeam.innerHTML = `
                    <div class="team-logo-container">
                        <img class="team-logo" src="${team.logo}" alt="${team.name}" onerror="this.style.display='none'">
                        <span class="seed">#${team.seed}</span>
                    </div>
                    <span class="team-name">${team.name}</span>
                `;
                sbTeam.onclick = () => selectSBTeam(sbTeam);

            } else if (round === 'sb') {
                // Champion!
                const championDiv = document.querySelector('.champion-team');
                championDiv.className = 'champion-team';
                championDiv.innerHTML = `
                    <span class="trophy">üèÜ</span>
                    <img class="team-logo" src="${team.logo}" alt="${team.name}" onerror="this.style.display='none'">
                    <span class="team-name">${team.name}</span>
                    <span class="trophy">üèÜ</span>
                `;
                bracket.champion = team;
            }
        }

        function recalcDivisionalMatchups(conference) {
            // Find all 3 winners from the Wild Card round
            const wcWinners = [];
            const wcMatchups = document.querySelectorAll(`[data-conference="${conference}"][data-round="wildcard"]`);
            
            wcMatchups.forEach(el => {
                if (el.classList.contains('winner')) {
                    const data = JSON.parse(el.dataset.teamData);
                    wcWinners.push(data);
                }
            });

            // If we don't have 3 winners yet, we cannot determine matchups
            if (wcWinners.length < 3) {
                // Reset Divisional slots 1, 2, 3
                updateSlot(null, conference, 'divisional', 1);
                updateSlot(null, conference, 'divisional', 2);
                updateSlot(null, conference, 'divisional', 3);
                return;
            }

            // We have 3 winners. Sort them by seed (ascending: 1 is best, 7 is worst)
            wcWinners.sort((a, b) => a.seed - b.seed);

            // Lowest seed (highest number) plays #1 seed (Slot 0). So they go to Slot 1.
            const lowestSeedTeam = wcWinners[wcWinners.length - 1];
            
            // The other two play each other.
            // Best remaining seed (lowest number) goes to Slot 2 (Home).
            // Middle remaining seed goes to Slot 3 (Away).
            const bestRemaining = wcWinners[0];
            const middleRemaining = wcWinners[1];

            // Update slots
            updateSlot(lowestSeedTeam, conference, 'divisional', 1);
            updateSlot(bestRemaining, conference, 'divisional', 2);
            updateSlot(middleRemaining, conference, 'divisional', 3);
        }

        function selectSBTeam(teamDiv) {
            if (teamDiv.classList.contains('empty')) return;

            const teamData = JSON.parse(teamDiv.dataset.teamData);
            const slot = parseInt(teamDiv.dataset.slot);

            // Remove selection from both teams
            document.querySelectorAll('[data-round="sb"]').forEach(t =>
                t.classList.remove('selected', 'winner')
            );

            // Mark winner
            teamDiv.classList.add('selected', 'winner');

            // Advance to champion
            advanceTeam(teamData, teamDiv.dataset.conference, 'sb', 0);
        }

        function updateSlot(team, conference, round, slot) {
            const slotDiv = document.querySelector(
                `[data-conference="${conference}"][data-round="${round}"][data-slot="${slot}"]`
            );

            if (slotDiv) {
                if (team) {
                    slotDiv.className = 'team';
                    slotDiv.dataset.teamData = JSON.stringify(team);
                    slotDiv.innerHTML = `
                        <div class="team-logo-container">
                            <img class="team-logo" src="${team.logo}" alt="${team.name}" onerror="this.style.display='none'">
                            <span class="seed">#${team.seed}</span>
                        </div>
                        <span class="team-name">${team.name}</span>
                    `;
                    slotDiv.onclick = () => selectTeam(slotDiv);
                } else {
                    // Reset to empty/TBD
                    slotDiv.className = 'team empty';
                    delete slotDiv.dataset.teamData;
                    slotDiv.innerHTML = '<span>TBD</span>';
                    slotDiv.onclick = null;
                    
                    // Also recursively clear any subsequent rounds if this slot was a winner there
                    // But simply resetting this slot breaks the chain, which is sufficient visually.
                    // Ideally we should clear the next round slot if it depended on this one.
                    // For simplicity, we just leave the next round as is (it will be overwritten when we select again)
                    // or we could clear it. Let's just clear this one for now.
                }
            }
        }

        function resetBracket() {
            if (confirm('Are you sure you want to reset the bracket?')) {
                // Clear all round containers
                ['afc', 'nfc'].forEach(conf => {
                    ['wc', 'div', 'conf'].forEach(round => {
                        const container = document.getElementById(`${conf}-${round}-content`);
                        if (container) container.innerHTML = '';
                    });
                });

                // Reset Super Bowl slots
                document.querySelectorAll('[data-round="sb"]').forEach(team => {
                    team.className = 'team empty';
                    team.innerHTML = team.dataset.slot === '0' ?
                        '<span>AFC Champion</span>' :
                        '<span>NFC Champion</span>';
                    team.onclick = null;
                });

                // Reset Champion
                const championDiv = document.querySelector('.champion-team');
                championDiv.className = 'champion-team empty';
                championDiv.innerHTML = '<span>TBD</span>';

                // Reinitialize bracket
                initBracket();
            }
        }

        // CRC32 Table for PNG metadata
        const crcTable = [];
        for (let n = 0; n < 256; n++) {
            let c = n;
            for (let k = 0; k < 8; k++) {
                if (c & 1) c = 0xedb88320 ^ (c >>> 1);
                else c = c >>> 1;
            }
            crcTable[n] = c;
        }

        function crc32(buf) {
            let c = 0xffffffff;
            for (let i = 0; i < buf.length; i++) {
                c = crcTable[(c ^ buf[i]) & 0xff] ^ (c >>> 8);
            }
            return c ^ 0xffffffff;
        }

        function addMetadataToPNG(pngBuffer, key, value) {
            const keyBytes = new TextEncoder().encode(key);
            const valueBytes = new TextEncoder().encode(value);
            
            // tEXt chunk: length (4) + 'tEXt' (4) + key + null (1) + value + crc (4)
            const chunkLen = keyBytes.length + 1 + valueBytes.length;
            const totalChunkLen = chunkLen + 12; // 4 len + 4 type + 4 crc
            
            const chunk = new Uint8Array(totalChunkLen);
            const view = new DataView(chunk.buffer);
            
            // Length
            view.setUint32(0, chunkLen);
            
            // Type
            chunk.set([116, 69, 88, 116], 4); // 'tEXt'
            
            // Data
            chunk.set(keyBytes, 8);
            chunk[8 + keyBytes.length] = 0; // null separator
            chunk.set(valueBytes, 8 + keyBytes.length + 1);
            
            // CRC (calculated over Type + Data)
            const crc = crc32(chunk.slice(4, totalChunkLen - 4));
            view.setUint32(totalChunkLen - 4, crc);
            
            // Insert after IHDR (standard PNG header is 33 bytes: 8 sig + 25 IHDR chunk)
            const newPng = new Uint8Array(pngBuffer.byteLength + totalChunkLen);
            newPng.set(new Uint8Array(pngBuffer.slice(0, 33)), 0);
            newPng.set(chunk, 33);
            newPng.set(new Uint8Array(pngBuffer.slice(33)), 33 + totalChunkLen);
            
            return newPng.buffer;
        }

        function getBracketState() {
            const predictions = [];
            
            // Capture all teams that have advanced to Divisional, Conference, or Super Bowl rounds
            document.querySelectorAll('.team[data-team-data]').forEach(el => {
                if (el.classList.contains('empty')) return;
                
                const round = el.dataset.round;
                // We only care about rounds that represent a user prediction/advancement
                if (round === 'divisional' || round === 'conference' || round === 'sb') {
                    const teamData = JSON.parse(el.dataset.teamData);
                    predictions.push({
                        round: round,
                        conference: el.dataset.conference,
                        slot: el.dataset.slot,
                        team: teamData.abbr
                    });
                }
            });

            if (bracket.champion) {
                predictions.push({
                    round: 'champion',
                    team: bracket.champion.abbr
                });
            }

            return {
                timestamp: new Date().toISOString(),
                predictions: predictions
            };
        }

        async function exportBracket() {
            const downloadBtn = document.querySelector('button[onclick="exportBracket()"]');
            const loadingOverlay = document.getElementById('loading-overlay');
            
            const bracketElement = document.getElementById('bracket');
            const creatorInput = document.getElementById('creator-name');
            const creatorName = creatorInput.value.trim() || 'Anonymous';

            // Set loading state
            if (downloadBtn) downloadBtn.disabled = true;
            if (loadingOverlay) loadingOverlay.classList.add('active');

            const state = getBracketState();
            state.creator = creatorName;

            // Save to database
            fetch('/.netlify/functions/save-bracket', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(state)
            }).catch(() => {});

            const now = new Date();
            const dateStr = now.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });
            const timeStr = now.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit'
            });

            try {
                const tempWrapper = document.createElement('div');
                tempWrapper.style.backgroundColor = '#ffffff';
                tempWrapper.style.padding = '30px';
                tempWrapper.style.width = 'fit-content';
                tempWrapper.style.position = 'absolute';
                tempWrapper.style.left = '-9999px';
                tempWrapper.style.top = '0';

                const title = document.createElement('h1');
                title.style.textAlign = 'center';
                title.style.color = '#013369';
                title.style.fontFamily = 'Arial, sans-serif';
                title.style.marginBottom = '20px';
                title.style.fontSize = '28px';
                title.textContent = 'NFL Playoff 2025-2026 Bracket Predictor';
                tempWrapper.appendChild(title);

                const bracketClone = bracketElement.cloneNode(true);
                tempWrapper.appendChild(bracketClone);

                const creatorInfo = document.createElement('div');
                creatorInfo.style.textAlign = 'center';
                creatorInfo.style.marginTop = '20px';
                creatorInfo.style.paddingTop = '15px';
                creatorInfo.style.borderTop = '2px solid #eee';
                creatorInfo.style.fontSize = '14px';
                creatorInfo.style.color = '#666';
                creatorInfo.style.fontFamily = 'Arial, sans-serif';
                creatorInfo.innerHTML = `Created by <strong>${creatorName}</strong> on ${dateStr} at ${timeStr}`;
                tempWrapper.appendChild(creatorInfo);

                document.body.appendChild(tempWrapper);

                const images = tempWrapper.querySelectorAll('img');
                await Promise.all(Array.from(images).map(img => {
                    if (img.complete) return Promise.resolve();
                    return new Promise((resolve) => {
                        img.onload = resolve;
                        img.onerror = resolve;
                    });
                }));

                const canvas = await html2canvas(tempWrapper, {
                    scale: 2,
                    backgroundColor: '#ffffff',
                    logging: false,
                    useCORS: true,
                    allowTaint: false,
                    windowWidth: tempWrapper.scrollWidth + 60,
                    windowHeight: tempWrapper.scrollHeight + 60
                });

                document.body.removeChild(tempWrapper);

                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

                canvas.toBlob(async (blob) => {
                    try {
                        const buffer = await blob.arrayBuffer();
                        const stateForMetadata = getBracketState();
                        stateForMetadata.creator = creatorName;
                        
                        const jsonStr = JSON.stringify(stateForMetadata);
                        const newBuffer = addMetadataToPNG(buffer, "nflBracketData", jsonStr);
                        const newBlob = new Blob([newBuffer], { type: 'image/png' });
                        
                        const url = URL.createObjectURL(newBlob);
                        
                        if (isMobile) {
                            // On mobile, sometimes direct download fails in embedded browsers.
                            // Open the image in a new tab so they can long-press to save.
                            const imgWindow = window.open('');
                            if (imgWindow) {
                                imgWindow.document.write(`
                                    <html>
                                        <head><title>Your NFL Bracket</title></head>
                                        <body style="margin:0; display:flex; flex-direction:column; align-items:center; background:#333; color:white; font-family:sans-serif;">
                                            <p style="padding:20px; text-align:center;">Long-press the image to Save to Photos</p>
                                            <img src="${url}" style="max-width:100%; height:auto;">
                                        </body>
                                    </html>
                                `);
                            } else {
                                // Fallback if popup blocked
                                const link = document.createElement('a');
                                link.download = 'nfl-playoff-bracket-2026.png';
                                link.href = url;
                                link.click();
                            }
                        } else {
                            const link = document.createElement('a');
                            link.download = 'nfl-playoff-bracket-2026.png';
                            link.href = url;
                            link.click();
                        }
                        
                        setTimeout(() => URL.revokeObjectURL(url), 10000);
                    } catch (e) {
                        console.error('Download failed:', e);
                        const url = canvas.toDataURL('image/png');
                        if (isMobile) {
                            window.open(url);
                        } else {
                            const link = document.createElement('a');
                            link.download = 'nfl-playoff-bracket-2026.png';
                            link.href = url;
                            link.click();
                        }
                    } finally {
                        if (downloadBtn) downloadBtn.disabled = false;
                        if (loadingOverlay) loadingOverlay.classList.remove('active');
                    }
                }, 'image/png');
            } catch (error) {
                console.error('Export failed:', error);
                alert('Failed to export bracket. Please try again.');
                if (downloadBtn) downloadBtn.disabled = false;
                if (loadingOverlay) loadingOverlay.classList.remove('active');
            }
        }

        // Check for create mode (for results entry later)
        const urlParams = new URLSearchParams(window.location.search);
        const createMode = urlParams.get('mode') === 'create';

        // Initialize on load
        initBracket();

        // Stats mode is default, unless create mode is specified
        if (!createMode) {
            enableStatsMode();
        }

        function animateAliveCount(finalValue) {
            const element = document.getElementById('alive-count');
            let iterations = 0;
            const maxIterations = 20;
            const interval = setInterval(() => {
                // Generate random 2-digit number (10-99)
                const randomNum = Math.floor(Math.random() * 90) + 10;
                element.textContent = randomNum;
                iterations++;
                
                if (iterations >= maxIterations) {
                    clearInterval(interval);
                    element.textContent = finalValue;
                }
            }, 50);
        }

        // Bracket viewer state
        let allBrackets = [];
        let leaderboardBrackets = []; // Top 10 for navigation
        let currentBracketIndex = 0;
        let currentResults = {};
        let isViewerMode = false;
        let isLeaderboardMode = false;

        async function openLeaderboard() {
            // Fetch brackets data
            try {
                const response = await fetch('/.netlify/functions/get-brackets');
                const data = await response.json();
                
                if (data.error) {
                    console.error('Brackets error:', data.error);
                    return;
                }

                allBrackets = data.brackets;
                currentResults = data.results;
                
                // Get top 10 for leaderboard
                leaderboardBrackets = allBrackets.slice(0, 10);
                isLeaderboardMode = true;

                // Switch headers
                document.getElementById('stats-header').style.display = 'none';
                document.getElementById('leaderboard-header').style.display = 'block';

                // Render leaderboard list
                renderLeaderboard();
            } catch (error) {
                console.error('Failed to load brackets:', error);
            }
        }

        function renderLeaderboard() {
            const listEl = document.getElementById('leaderboard-list');
            listEl.innerHTML = '';

            leaderboardBrackets.forEach((bracket, index) => {
                const rank = index + 1;
                const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : '';
                
                const item = document.createElement('div');
                item.className = 'leaderboard-item';
                item.onclick = () => openBracketFromLeaderboard(index);
                item.innerHTML = `
                    <span class="leaderboard-rank ${rankClass}">#${rank}</span>
                    <span class="leaderboard-creator">${bracket.creator}</span>
                    <span class="leaderboard-score">${bracket.score} pts</span>
                `;
                listEl.appendChild(item);
            });
        }

        function closeLeaderboard() {
            isLeaderboardMode = false;
            
            // Switch headers back
            document.getElementById('leaderboard-header').style.display = 'none';
            document.getElementById('stats-header').style.display = 'block';

            // Re-enable stats mode display
            enableStatsMode();
        }

        function openBracketFromLeaderboard(index) {
            currentBracketIndex = index;
            isViewerMode = true;
            isLeaderboardMode = false;

            // Switch headers
            document.getElementById('leaderboard-header').style.display = 'none';
            document.getElementById('bracket-viewer-header').style.display = 'block';

            // Display bracket
            displayBracket(currentBracketIndex);
        }

        function closeToLeaderboard() {
            isViewerMode = false;
            
            // Switch headers back
            document.getElementById('bracket-viewer-header').style.display = 'none';
            document.getElementById('leaderboard-header').style.display = 'block';
        }

        function prevBracket() {
            if (currentBracketIndex > 0) {
                currentBracketIndex--;
                displayBracket(currentBracketIndex);
            }
        }

        function nextBracket() {
            if (currentBracketIndex < leaderboardBrackets.length - 1) {
                currentBracketIndex++;
                displayBracket(currentBracketIndex);
            }
        }

        function displayBracket(index) {
            const bracket = leaderboardBrackets[index];
            if (!bracket) return;

            const rank = index + 1;
            const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : '';

            // Update rank display
            const rankEl = document.getElementById('bracket-rank');
            rankEl.textContent = '#' + rank;
            rankEl.className = 'bracket-rank ' + rankClass;

            // Update header info
            document.getElementById('bracket-creator-name').textContent = 'Bracket by: ' + bracket.creator;
            document.getElementById('bracket-position').textContent = rank + ' / ' + leaderboardBrackets.length;
            document.getElementById('bracket-score').textContent = 'Score: ' + bracket.score + ' pts';

            // Show/hide navigation arrows based on position
            document.getElementById('prev-btn').style.visibility = index === 0 ? 'hidden' : 'visible';
            document.getElementById('next-btn').style.visibility = index === leaderboardBrackets.length - 1 ? 'hidden' : 'visible';

            // Clear existing bracket and rebuild with this user's predictions
            resetBracketDisplay();
            populateBracketFromPredictions(bracket.predictions);
        }

        function resetBracketDisplay() {
            // Reset all team slots to empty state
            document.querySelectorAll('[data-round="divisional"], [data-round="conference"], [data-round="sb"]').forEach(slot => {
                if (slot.classList.contains('team')) {
                    slot.className = 'team empty';
                    slot.innerHTML = '<span>TBD</span>';
                    slot.dataset.teamData = '';
                }
            });

            // Reset champion
            const championDiv = document.querySelector('.champion-team');
            if (championDiv) {
                championDiv.className = 'champion-team empty';
                championDiv.innerHTML = '<span>TBD</span>';
            }

            // Remove any stats badges
            document.querySelectorAll('.stats-badge, .team-score').forEach(el => el.remove());
        }

        function populateBracketFromPredictions(predictions) {
            if (!Array.isArray(predictions)) return;

            predictions.forEach(pred => {
                const { round, conference, slot, team: teamAbbr } = pred;
                
                // Find the team data
                let teamData = null;
                for (const conf of ['AFC', 'NFC']) {
                    const found = teams[conf].find(t => t.abbr === teamAbbr);
                    if (found) {
                        teamData = found;
                        break;
                    }
                }
                if (!teamData) return;

                if (round === 'champion') {
                    // Display champion
                    const championDiv = document.querySelector('.champion-team');
                    if (championDiv) {
                        championDiv.className = 'champion-team';
                        championDiv.innerHTML = `
                            <span class="trophy">üèÜ</span>
                            <img class="team-logo" src="${teamData.logo}" alt="${teamData.name}" onerror="this.style.display='none'">
                            <span class="team-name">${teamData.name}</span>
                        `;
                    }
                } else {
                    // Find the slot
                    const slotDiv = document.querySelector(
                        `[data-conference="${conference}"][data-round="${round}"][data-slot="${slot}"]`
                    );
                    
                    if (slotDiv) {
                        slotDiv.className = 'team';
                        slotDiv.innerHTML = `
                            <span class="seed">${teamData.seed}</span>
                            <img class="team-logo" src="${teamData.logo}" alt="${teamData.name}" onerror="this.style.display='none'">
                            <span class="team-name">${teamData.name}</span>
                        `;
                        slotDiv.dataset.teamData = JSON.stringify(teamData);
                    }
                }
            });

            // Apply result styling to all rounds
            applyResultsToBracket(predictions);
        }

        function applyResultsToBracket(predictions) {
            // Apply winner/loser styling based on results for all rounds
            for (const key in currentResults) {
                const result = currentResults[key];
                const [round, conference, matchupId] = key.split('-');
                
                if (round === 'wildcard') {
                    // Find the Wild Card teams for this matchup
                    const wcTeams = document.querySelectorAll(
                        `[data-conference="${conference}"][data-round="wildcard"]`
                    );
                    
                    wcTeams.forEach(teamDiv => {
                        if (!teamDiv.dataset.teamData) return;
                        const teamData = JSON.parse(teamDiv.dataset.teamData);
                        const teamMatchupId = getWcMatchupId(teamData.seed);
                        
                        if (teamMatchupId === parseInt(matchupId)) {
                            // Add score
                            const score = document.createElement('div');
                            score.className = 'team-score';
                            score.textContent = teamData.abbr === result.team1 ? result.score1 : result.score2;
                            teamDiv.appendChild(score);

                            // Add winner/loser class
                            if (teamData.abbr === result.winner) {
                                teamDiv.classList.add('result-winner');
                            } else {
                                teamDiv.classList.add('result-loser');
                            }
                        }
                    });

                    // Check if user predicted the WC winner correctly (winner should be in divisional)
                    const predictedWinner = predictions.find(p => 
                        p.round === 'divisional' && 
                        p.conference === conference &&
                        (p.team === result.team1 || p.team === result.team2)
                    );
                    
                    if (predictedWinner) {
                        // Find the divisional slot with this prediction
                        const divSlot = document.querySelector(
                            `[data-conference="${conference}"][data-round="divisional"][data-slot="${predictedWinner.slot}"]`
                        );
                        if (divSlot && divSlot.dataset.teamData) {
                            const teamData = JSON.parse(divSlot.dataset.teamData);
                            if (teamData.abbr === result.winner) {
                                divSlot.classList.add('prediction-correct');
                            } else {
                                divSlot.classList.add('prediction-wrong');
                            }
                        }
                    }
                }

                if (round === 'divisional') {
                    // Check if user predicted the divisional winner correctly
                    const predictedWinner = predictions.find(p => 
                        p.round === 'conference' && 
                        p.conference === conference &&
                        (p.team === result.winner || p.team === result.team1 || p.team === result.team2)
                    );
                    
                    if (predictedWinner) {
                        const confSlot = document.querySelector(
                            `[data-conference="${conference}"][data-round="conference"][data-slot="${predictedWinner.slot}"]`
                        );
                        if (confSlot && confSlot.dataset.teamData) {
                            const teamData = JSON.parse(confSlot.dataset.teamData);
                            if (teamData.abbr === result.winner) {
                                confSlot.classList.add('prediction-correct');
                            } else if (teamData.abbr === result.team1 || teamData.abbr === result.team2) {
                                confSlot.classList.add('prediction-wrong');
                            }
                        }
                    }
                }

                if (round === 'conference') {
                    // Check if user predicted the conference winner correctly
                    const predictedWinner = predictions.find(p => 
                        p.round === 'sb' && 
                        p.conference === conference
                    );
                    
                    if (predictedWinner) {
                        const sbSlot = document.querySelector(
                            `[data-conference="${conference}"][data-round="sb"]`
                        );
                        if (sbSlot && sbSlot.dataset.teamData) {
                            const teamData = JSON.parse(sbSlot.dataset.teamData);
                            if (teamData.abbr === result.winner) {
                                sbSlot.classList.add('prediction-correct');
                            } else if (teamData.abbr === result.team1 || teamData.abbr === result.team2) {
                                sbSlot.classList.add('prediction-wrong');
                            }
                        }
                    }
                }

                if (round === 'sb') {
                    // Check if user predicted the SB winner correctly
                    const predictedChampion = predictions.find(p => p.round === 'champion');
                    
                    if (predictedChampion) {
                        const championDiv = document.querySelector('.champion-team');
                        if (championDiv) {
                            if (predictedChampion.team === result.winner) {
                                championDiv.classList.add('prediction-correct');
                            } else {
                                championDiv.classList.add('prediction-wrong');
                            }
                        }
                    }
                }
            }
        }

        async function enableStatsMode() {
            // Add stats-mode class to body
            document.body.classList.add('stats-mode');

            // Hide prediction controls
            document.querySelector('.creator-info').style.display = 'none';
            document.querySelector('.controls').style.display = 'none';
            document.getElementById('countdown-container').style.display = 'none';

            // Show stats header
            document.getElementById('stats-header').style.display = 'block';

            // Hide the original header
            document.querySelector('header').style.display = 'none';

            // Disable all team click handlers
            document.querySelectorAll('.team').forEach(team => {
                team.onclick = null;
                team.style.cursor = 'default';
            });

            // Fetch and display stats
            try {
                const response = await fetch('/.netlify/functions/get-stats');
                const data = await response.json();

                if (data.error) {
                    console.error('Stats error:', data.error);
                    return;
                }

                const totalBrackets = data.totalBrackets;

                // Animate alive count with cycling numbers
                animateAliveCount(data.aliveBrackets);

                // Display stats on Wild Card teams and advance winners to divisional
                displayWildCardStats(data.wcStats, data.results);

                // Compute and display divisional stats
                displayDivisionalStats(data.roundCounts, totalBrackets, data.results);

                // Compute and display conference stats
                displayConferenceStats(data.roundCounts, totalBrackets, data.results);

                // Compute and display Super Bowl stats
                displaySuperBowlStats(data.champion, totalBrackets);

            } catch (error) {
                console.error('Failed to fetch stats:', error);
            }
        }

        // Map team seeds to WC matchup IDs
        // Matchup 0: #2 vs #7, Matchup 1: #3 vs #6, Matchup 2: #4 vs #5
        function getWcMatchupId(seed) {
            if (seed === 2 || seed === 7) return 0;
            if (seed === 3 || seed === 6) return 1;
            if (seed === 4 || seed === 5) return 2;
            return -1; // #1 seed has bye
        }

        function displayWildCardStats(wcStats, results) {
            // wcStats structure: { "AFC-0": { "NE": 60, "LAC": 40, total: X }, ... }
            // Matchup 0 = #2 vs #7, Matchup 1 = #3 vs #6, Matchup 2 = #4 vs #5

            // Track winners to advance to divisional (actual results take priority)
            const wcWinners = { AFC: [], NFC: [] };

            ['AFC', 'NFC'].forEach(conference => {
                // Get all Wild Card teams (not the bye team)
                const wcTeams = document.querySelectorAll(
                    `[data-conference="${conference}"][data-round="wildcard"]`
                );

                // Group teams by matchup for color coding
                const matchupTeams = {};
                wcTeams.forEach(teamDiv => {
                    if (!teamDiv.dataset.teamData) return;
                    const teamData = JSON.parse(teamDiv.dataset.teamData);
                    const matchupId = getWcMatchupId(teamData.seed);
                    if (matchupId === -1) return;
                    
                    if (!matchupTeams[matchupId]) matchupTeams[matchupId] = [];
                    matchupTeams[matchupId].push({ teamDiv, teamData });
                });

                // Process each matchup and color code badges
                Object.keys(matchupTeams).forEach(matchupId => {
                    const teamsInMatchup = matchupTeams[matchupId];
                    if (teamsInMatchup.length !== 2) return;

                    const statsKey = `${conference}-${matchupId}`;
                    const matchupStats = wcStats[statsKey];
                    const resultKey = `wildcard-${conference}-${matchupId}`;
                    const result = results?.[resultKey];

                    const team1 = teamsInMatchup[0];
                    const team2 = teamsInMatchup[1];
                    
                    const pct1 = matchupStats?.[team1.teamData.abbr] || 0;
                    const pct2 = matchupStats?.[team2.teamData.abbr] || 0;

                    // Add badges with color coding
                    addStatsBadge(team1.teamDiv, pct1, false, pct1 > pct2 ? 'higher' : 'lower');
                    addStatsBadge(team2.teamDiv, pct2, false, pct2 > pct1 ? 'higher' : 'lower');

                    // Apply result styling if game is complete
                    if (result) {
                        applyResultStyling(team1.teamDiv, team1.teamData.abbr, result);
                        applyResultStyling(team2.teamDiv, team2.teamData.abbr, result);
                        
                        // Use actual winner for advancement
                        const winnerData = result.winner === team1.teamData.abbr ? team1.teamData : team2.teamData;
                        wcWinners[conference].push(winnerData);
                    } else {
                        // No result yet, use prediction-based winner
                        if (pct1 > pct2) {
                            wcWinners[conference].push(team1.teamData);
                        } else if (pct2 > pct1) {
                            wcWinners[conference].push(team2.teamData);
                        }
                    }
                });

                // Advance winners to divisional round (with isActualResult flag)
                const hasAllResults = Object.keys(matchupTeams).every(matchupId => {
                    const resultKey = `wildcard-${conference}-${matchupId}`;
                    return results?.[resultKey];
                });
                advanceWcWinnersToDivisional(conference, wcWinners[conference], hasAllResults);
            });
        }

        function applyResultStyling(teamDiv, teamAbbr, result) {
            // Add score display
            const score = document.createElement('div');
            score.className = 'team-score';
            score.textContent = teamAbbr === result.team1 ? result.score1 : result.score2;
            teamDiv.appendChild(score);

            // Add winner/loser class
            if (teamAbbr === result.winner) {
                teamDiv.classList.add('result-winner');
            } else {
                teamDiv.classList.add('result-loser');
            }
        }

        function advanceWcWinnersToDivisional(conference, winners, isActualResult = false) {
            if (winners.length < 3) return;

            // Sort winners by seed (ascending - lowest seed number is best)
            winners.sort((a, b) => a.seed - b.seed);

            // NFL reseeding: #1 seed plays lowest remaining seed
            // Slot 1: lowest seed (highest number) plays #1
            // Slot 2: best remaining (lowest seed number)
            // Slot 3: middle remaining

            const lowestSeed = winners[winners.length - 1]; // highest seed number
            const bestRemaining = winners[0];
            const middleRemaining = winners[1];

            // Update divisional slots - if actual result, don't style as predicted (grey)
            const isPredicted = !isActualResult;
            updateSlotWithStats(lowestSeed, conference, 'divisional', 1, isPredicted);
            updateSlotWithStats(bestRemaining, conference, 'divisional', 2, isPredicted);
            updateSlotWithStats(middleRemaining, conference, 'divisional', 3, isPredicted);
        }

        function updateSlotWithStats(team, conference, round, slot, isPredicted = true) {
            const selector = `[data-conference="${conference}"][data-round="${round}"][data-slot="${slot}"]`;
            const slotDiv = document.querySelector(selector);
            
            if (!slotDiv) return;

            slotDiv.className = isPredicted ? 'team predicted' : 'team';
            slotDiv.dataset.teamData = JSON.stringify(team);
            slotDiv.innerHTML = `
                <div class="team-logo-container">
                    <img class="team-logo" src="${team.logo}" alt="${team.name}" onerror="this.style.display='none'">
                    <span class="seed">#${team.seed}</span>
                </div>
                <span class="team-name">${team.name}</span>
            `;
        }

        function displayDivisionalStats(roundCounts, totalBrackets, results) {
            // Divisional matchups:
            // Matchup 0: #1 seed vs lowest remaining (slot 0 vs slot 1)
            // Matchup 1: best remaining vs middle remaining (slot 2 vs slot 3)
            
            const divMatchups = {
                AFC: [[0, 1], [2, 3]],
                NFC: [[0, 1], [2, 3]]
            };

            const confCounts = roundCounts.conference || {};

            ['AFC', 'NFC'].forEach(conference => {
                divMatchups[conference].forEach((matchup, matchupIdx) => {
                    const slot1 = matchup[0];
                    const slot2 = matchup[1];

                    // Get teams in these slots
                    const team1Div = document.querySelector(
                        `[data-conference="${conference}"][data-round="divisional"][data-slot="${slot1}"]`
                    );
                    const team2Div = document.querySelector(
                        `[data-conference="${conference}"][data-round="divisional"][data-slot="${slot2}"]`
                    );

                    if (!team1Div || !team2Div) return;
                    if (!team1Div.dataset.teamData || !team2Div.dataset.teamData) return;

                    const team1Data = JSON.parse(team1Div.dataset.teamData);
                    const team2Data = JSON.parse(team2Div.dataset.teamData);

                    // Get counts from conference round (who advanced from divisional)
                    // Use percentage of ALL brackets, not normalized per-matchup
                    const count1 = confCounts[team1Data.abbr] || 0;
                    const count2 = confCounts[team2Data.abbr] || 0;

                    const pct1 = totalBrackets > 0 ? Math.round((count1 / totalBrackets) * 100) : 0;
                    const pct2 = totalBrackets > 0 ? Math.round((count2 / totalBrackets) * 100) : 0;

                    // Add stats badges with color coding (no scores for divisional)
                    addStatsBadge(team1Div, pct1, false, pct1 > pct2 ? 'higher' : 'lower');
                    addStatsBadge(team2Div, pct2, false, pct2 > pct1 ? 'higher' : 'lower');

                    // Check for divisional result and apply styling
                    const resultKey = `divisional-${conference}-${matchupIdx}`;
                    const result = results?.[resultKey];
                    
                    if (result) {
                        applyResultStyling(team1Div, team1Data.abbr, result);
                        applyResultStyling(team2Div, team2Data.abbr, result);
                        // Advance actual winner to conference
                        const winnerData = result.winner === team1Data.abbr ? team1Data : team2Data;
                        advanceToConference(winnerData, conference, matchupIdx);
                    } else {
                        // Advance predicted winner to conference round (based on raw count)
                        if (count1 > count2) {
                            advanceToConference(team1Data, conference, matchupIdx);
                        } else if (count2 > count1) {
                            advanceToConference(team2Data, conference, matchupIdx);
                        }
                    }
                });
            });
        }

        function advanceToConference(team, conference, slot) {
            updateSlotWithStats(team, conference, 'conference', slot, true);
        }

        function displayConferenceStats(roundCounts, totalBrackets, results) {
            const sbCounts = roundCounts.sb || {};

            ['AFC', 'NFC'].forEach(conference => {
                // Conference matchup: slot 0 vs slot 1
                const team1Div = document.querySelector(
                    `[data-conference="${conference}"][data-round="conference"][data-slot="0"]`
                );
                const team2Div = document.querySelector(
                    `[data-conference="${conference}"][data-round="conference"][data-slot="1"]`
                );

                if (!team1Div || !team2Div) return;
                if (!team1Div.dataset.teamData || !team2Div.dataset.teamData) return;

                const team1Data = JSON.parse(team1Div.dataset.teamData);
                const team2Data = JSON.parse(team2Div.dataset.teamData);

                // Get counts from SB round (who advanced from conference)
                // Use percentage of ALL brackets, not normalized per-matchup
                const count1 = sbCounts[team1Data.abbr] || 0;
                const count2 = sbCounts[team2Data.abbr] || 0;

                const pct1 = totalBrackets > 0 ? Math.round((count1 / totalBrackets) * 100) : 0;
                const pct2 = totalBrackets > 0 ? Math.round((count2 / totalBrackets) * 100) : 0;

                // Add stats badges with color coding (no scores)
                addStatsBadge(team1Div, pct1, false, pct1 > pct2 ? 'higher' : 'lower');
                addStatsBadge(team2Div, pct2, false, pct2 > pct1 ? 'higher' : 'lower');

                // Check for conference result and apply styling
                const resultKey = `conference-${conference}-0`;
                const result = results?.[resultKey];

                if (result) {
                    applyResultStyling(team1Div, team1Data.abbr, result);
                    applyResultStyling(team2Div, team2Data.abbr, result);
                    // Advance actual winner to Super Bowl
                    const winnerData = result.winner === team1Data.abbr ? team1Data : team2Data;
                    advanceToSuperBowl(winnerData, conference);
                } else {
                    // Advance predicted winner to Super Bowl (based on raw count)
                    if (count1 > count2) {
                        advanceToSuperBowl(team1Data, conference);
                    } else if (count2 > count1) {
                        advanceToSuperBowl(team2Data, conference);
                    }
                }
            });
        }

        function advanceToSuperBowl(team, conference) {
            const sbSlot = conference === 'AFC' ? 0 : 1;
            const sbTeam = document.querySelector(`[data-round="sb"][data-slot="${sbSlot}"]`);

            if (!sbTeam) return;

            sbTeam.className = 'team predicted';
            sbTeam.dataset.teamData = JSON.stringify(team);
            sbTeam.dataset.conference = conference.toLowerCase();
            sbTeam.innerHTML = `
                <div class="team-logo-container">
                    <img class="team-logo" src="${team.logo}" alt="${team.name}" onerror="this.style.display='none'">
                    <span class="seed">#${team.seed}</span>
                </div>
                <span class="team-name">${team.name}</span>
            `;
        }

        function displaySuperBowlStats(championStats, totalBrackets) {
            const afcTeamDiv = document.querySelector('[data-round="sb"][data-slot="0"]');
            const nfcTeamDiv = document.querySelector('[data-round="sb"][data-slot="1"]');

            if (!afcTeamDiv || !nfcTeamDiv) return;
            if (!afcTeamDiv.dataset.teamData || !nfcTeamDiv.dataset.teamData) return;

            const afcTeam = JSON.parse(afcTeamDiv.dataset.teamData);
            const nfcTeam = JSON.parse(nfcTeamDiv.dataset.teamData);

            // Get champion counts for these two teams
            // Use percentage of ALL brackets, not normalized per-matchup
            const afcCount = championStats[afcTeam.abbr] || 0;
            const nfcCount = championStats[nfcTeam.abbr] || 0;

            const afcPct = totalBrackets > 0 ? Math.round((afcCount / totalBrackets) * 100) : 0;
            const nfcPct = totalBrackets > 0 ? Math.round((nfcCount / totalBrackets) * 100) : 0;

            // Add stats badges with color coding (no scores)
            addStatsBadge(afcTeamDiv, afcPct, false, afcPct > nfcPct ? 'higher' : 'lower');
            addStatsBadge(nfcTeamDiv, nfcPct, false, nfcPct > afcPct ? 'higher' : 'lower');

            // Advance winner to champion (based on raw count)
            if (afcCount > nfcCount) {
                displayChampion(afcTeam);
            } else if (nfcCount > afcCount) {
                displayChampion(nfcTeam);
            }
        }

        function displayChampion(team) {
            const championDiv = document.querySelector('.champion-team');
            if (!championDiv) return;

            championDiv.className = 'champion-team predicted';
            championDiv.innerHTML = `
                <img class="team-logo" src="${team.logo}" alt="${team.name}" onerror="this.style.display='none'">
                <span class="team-name">${team.name}</span>
            `;
        }

        function addStatsBadge(teamDiv, percentage, showScore = false, colorClass = '') {
            // Make team div position relative for absolute badge positioning
            teamDiv.style.position = 'relative';

            // Add percentage badge (top-left)
            const badge = document.createElement('div');
            badge.className = 'stats-badge' + (colorClass ? ' ' + colorClass : '');
            badge.textContent = percentage + '%';
            teamDiv.appendChild(badge);

            // Add score display (right side) - only for Wild Card
            if (showScore) {
                const score = document.createElement('div');
                score.className = 'team-score';
                // Random 1-2 digit score for mockup
                score.textContent = Math.floor(Math.random() * 90) + 10;
                teamDiv.appendChild(score);
            }
        }

        // Countdown Timer Logic
        function updateCountdown() {
            // Target: Jan 10, 2026, 11:30 PM EST 
            // EST is UTC-5. Jan 10 23:30 EST = Jan 11 04:30 UTC
            const targetDate = new Date("2026-01-11T04:30:00Z").getTime();
            
            const timer = setInterval(() => {
                const now = new Date().getTime();
                const distance = targetDate - now;

                if (distance < 0) {
                    clearInterval(timer);
                    document.getElementById("countdown").innerHTML = "KICKOFF!";
                    return;
                }

                const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);

                document.getElementById("days").innerText = String(days).padStart(2, '0');
                document.getElementById("hours").innerText = String(hours).padStart(2, '0');
                document.getElementById("minutes").innerText = String(minutes).padStart(2, '0');
                document.getElementById("seconds").innerText = String(seconds).padStart(2, '0');
            }, 1000);
        }

        updateCountdown();
    </script>
</body>
</html>
